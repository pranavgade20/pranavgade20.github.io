[{"content":"I participated in TrollCAT CTF with my team, Pwnzorz, this weekend, and we placed 2nd! Considering that this was our first CTF in quite a while, we did really well, thanks to my amazing teammates Aayushman, Nils, and Uzay-G. Here are the writeups for the challenges I completed.\nReversing - Solver The challenge, archived here, says can you guess the password? and gives you a binary to reverse. Using ghidra, we get the following disassembly:\n1 2 3 4 5 6 7 8 9 10  if ((int)input[3] + (int)*input == 100) { if ((int) input[0x12] + (int) input[1] == 0xd6) { if ((int) input[4] + (int) input[2] == 0xb2) { if ((char) (input[6] ^ input[5]) == 0x4c) { if ((int) input[8] - (int) input[7] == 0x11) { if ((int) input[10] - (int) input[9] == 0x3b) { if (((int) input[0xb] + (int) input[0xc]) - (int) input[0xd] == 0x45) { if (((int) input[0xe] + (int) input[0xf]) - (int) input[0x10] == 0x1f) { if (((int) input[0x11] + (int) input[0x10]) - (int) input[0x12] == 0x58) { if ((char) (input[0x15] ^ input[0x13] ^ input[0x14]) == 0x45) {   Now, you could be smart, and know that you are supposed to use the z3 solver, or you could be me. I thought that it did not look very complex, so I got a pen and paper and started solving it manually. For example, the first line wants the sum of the fourth and first characters to be 100. So, I just assumed both of them to equal 50, which is 2 in ASCII. Similarly, I solved all of them manually in about 30 minutes. Finally, one input satisfying all the conditions is 2lY2Y4xAR?zEEE@@aajEEE. Finally, after connecting to the server using nc, we are asked the key. Giving it 2lY2Y4xAR?zEEE@@aajEEE gives us the flag!\nWeb - Nested Exploration The challenge is a link, and a hint saying something nice happens when we submit 69 times.\nLooking at the requests in devtools, we can see that a POST request is made, followed by a GET request. The response of the POST request is empty, and the response of the GET request is the webpage with n forms, where n is the number of times we have submitted the form. I noticed that the request parameter has a number, and tried changing it to 69. However, this still gave me the same response. Then, I tried to look at the cookies set by the website. Sure enough, there was a cookie with a number that increased every time I submitted the form. I just set this to 68 and submitted the form, and sure enough, the flag was in a div in the end.\n","description":"Writeup for trollcat CTF from 6th Feb, 2021","id":0,"section":"posts","tags":["writeup","ctf"],"title":"TrollcatCTF Writeup","uri":"https://pranavgade20.github.io/blog/posts/trollcatctf-21-writeup/"},{"content":"block gate This is a writeup for the \u0026lsquo;block gate\u0026rsquo; challenge from WPICTF 2020.\nThis is a forensics challenge, and we are given a minecraft world.\nAs soon as we enter the world, we see a column of water falling\u0026ndash;wrecking redstone circuits doubtlessly important to the whole affair.\nSo, after reloading the world, we can use gnembon\u0026rsquo;s carpet mod to stop the flow of water using the /tick freeze command. This is how it looks after that:\nNow, we can take our time in clearing out the water by filling that region with air using the /fillcommand:\nTo see the effects, we need to un-freeze the game using /tick freeze and boom, the water disappears:\nNow, we can start looking at the redstone circuit. A closer look shows us that two of the connections might be missing:And we have 2 vacant inputs for the output panel as well: We can try connecting them so the circuit is complete:(The repeaters are for extending the signal)\nFinally, we can look at the output. It looks like they are 7 segment displays, and a quick google search gives us the corresponding symbols:\nWe can see the 7 segment displays, and their corresponding symbols.\nNow we have practically solved the challenge. All we need to do is read the displays as they light up and we can get our flag! However, since this is repeating in a cyclic pattern, we need to figure out the beginning of the sequence. We do know that the flag is supposed to start with WPI{, so we can use that to find the start of the sequence.\nTo make writing down the sequence easier, we can use /tick rate 10 to halve the speed of the sequence(or /tick rate 5 for quarter speed and so on). Now all we need to do is write down the flag as it appears and we get our flag!\n","description":"Writeup for trollcat CTF from 6th Feb, 2021","id":1,"section":"posts","tags":["writeup","ctf"],"title":"WpiCTF Writeup","uri":"https://pranavgade20.github.io/blog/posts/wpictf-20-writeup/"},{"content":"Background A quine is a program that produces its source code as its output. Now, although HTML is not a programming language, but a markup language, CSS is a turing complete language as long as you consider the accompanying HTML as well. So, this is technically a description of a HTML+CSS quine, but I think saying HTML is sufficient.\nI was introduced to the idea of a quine in the book GÃ¶del, Escher, Bach: An Eternal Golden Braid, by Douglas Hofstadter. After I stumbled across this this talk, I thought it would be a nice way to put up information about me, because I am lazy and suck at design. Surprisingly, this is a very straightforward quine, so here are more details.\nThe quine The magic we use here is all thanks to the ::before and ::after CSS selectors. If you are new to CSS, selectors are basically a way to select specific elements so that we can change their properties like font style, color, etc. So, p::before will select the element that precedes the paragraph tag in our HTML document, and allow us to insert whatever we want in there. For example, \u0026lt;p\u0026gt;! Because we want to convert \u0026lt;p\u0026gt; Hello, World! \u0026lt;/p\u0026gt; which renders as Hello, World! to \u0026lt;p\u0026gt; Hello, World!, this is the perfect solution. So, let us start writing the CSS step by step:\n1  p::before{content:\u0026#39;\u0026lt;p\u0026gt;\u0026#39;}   This adds a \u0026lt;p\u0026gt; before all paragraph elements. Similarly, we can add the ::after selector.\n1  p::before{content:\u0026#39;\u0026lt;p\u0026gt;\u0026#39;} p::after{content:\u0026#39;\u0026lt;/p\u0026gt;\u0026#39;}   Now, all our paragraphs are surrounded with the appropriate HTML tags. However, our HTML page has a number of other tags. We can simply do the same thing for them:\n1 2 3 4 5 6 7 8 9 10 11  html::before{content:\u0026#39;\u0026lt;html\u0026gt;\u0026#39;} html::after{content:\u0026#39;\u0026lt;/html\u0026gt;\u0026#39;} head::before{content:\u0026#39;\u0026lt;head\u0026gt;\u0026#39;} head::after{content:\u0026#39;\u0026lt;/head\u0026gt;\u0026#39;} title::before{content:\u0026#39;\u0026lt;title\u0026gt;\u0026#39;} title::after{content:\u0026#39;\u0026lt;/title\u0026gt;\u0026#39;} body::before{content:\u0026#39;\u0026lt;body\u0026gt;\u0026#39;} body::after{content:\u0026#39;\u0026lt;/body\u0026gt;\u0026#39;} h1::before{content:\u0026#39;\u0026lt;h1\u0026gt;\u0026#39;} h1::after{content:\u0026#39;\u0026lt;/h1\u0026gt;\u0026#39;} h3::before{content:\u0026#39;\u0026lt;h3\u0026gt;\u0026#39;} h3::after{content:\u0026#39;\u0026lt;/h3\u0026gt;\u0026#39;} h5::before{content:\u0026#39;\u0026lt;h5\u0026gt;\u0026#39;} h5::after{content:\u0026#39;\u0026lt;/h5\u0026gt;\u0026#39;} p::before{content:\u0026#39;\u0026lt;p\u0026gt;\u0026#39;} p::after{content:\u0026#39;\u0026lt;/p\u0026gt;\u0026#39;} table::before{content:\u0026#39;\u0026lt;table\u0026gt;\u0026#39;} table::after{content:\u0026#39;\u0026lt;/table\u0026gt;\u0026#39;} tr::before{content:\u0026#39;\u0026lt;tr\u0026gt;\u0026#39;} tr::after{content:\u0026#39;\u0026lt;/tr\u0026gt;\u0026#39;} td::before{content:\u0026#39;\u0026lt;td\u0026gt;\u0026#39;;} td::after{content:\u0026#39;\u0026lt;/td\u0026gt;\u0026#39;;}   It has been straightforward so far. However, there are a couple of minor issues. First, the \u0026lt;meta\u0026gt; tag. It does not have a closing tag, as everything is inside the tag as an attribute. The solution here is pretty straightforward: include the entire tag with the attributes in the ::before selector. So, we can have this for the meta tag:\n1  meta::before{content:\u0026#39;\u0026lt;meta charset=\u0026#34;utf-8\u0026#34; name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt;\u0026#39;}   Our second problem is the \u0026lt;a\u0026gt; tags, as they have hrefs which are different in different places. thankfully, CSS has an attr() function that gives us the value of the attribute(in out case, href). So, we can use the following CSS for dealing with hyperlinks:\n1  a[href]::before{content: \u0026#34;a href=\u0026#39;\u0026#34; attr(href) \u0026#34;\u0026#39;\u0026gt;\u0026#34;} a::after{content:\u0026#39;\u0026lt;/a\u0026gt;\u0026#39;} a{display:inline; text-decoration: none}   We used [href] to make sure we select the correct \u0026lt;a\u0026gt; tags, and the display:inline is just for formatting(more on this later). text-decoration:none removes the underlines from the hyperlinks.\nThe final challenge is \u0026lt;style\u0026gt; tags. Specifically, the content in the ::after selector. Because we are using style tags to enclose this CSS, if we use style::after{content:'\u0026lt;/style\u0026gt;'}, the \u0026lt;/style\u0026gt; is interpreted as a closing tag, which is not something we want to see happening. Thankfully, just escaping the slash solves our problem, and we get the following CSS for dealing with the style tags:\n1  style::before{content:\u0026#39;\u0026lt;style\u0026gt;\u0026#39;} style::after{content:\u0026#39;\u0026lt;\\/style\u0026gt;\u0026#39;}   Although you can see \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; now, the CSS we wrote in the document is missing. This bring us to arguably the most important piece of CSS in the document:\n1  *{display:block}   This makes the CSS we have written in the document visible. Now, we have a stylesheet with the surrounding tags. This is also the reason we need the display:inline in the \u0026lt;a\u0026gt; tags, as display:block makes the text go on a new line, which doesn\u0026rsquo;t look particularly nice.\nOur page is now technically a quine, and if you copy-paste the output of the HTML into a HTML, you should get the same HTML(yes, it does get somewhat confusing). However, this looks a bit bland. So, we sprinkle some CSS magic to format the different elements:\n1 2 3 4  html{max-width:99ch; padding:1ch; margin:auto; color:#333; font-size:1.2em} style{font-size: 0.4em} *::before, *::after{color:#aebfd0; font-weight:100; font-size:0.8em; margin:0.3em} *{display:block; font-family:Monospace}   We finally have the result: a HTML that generates itself on most modern browsers. You can visit the final version at https://pranavgade20.github.io. Finally, a caveat: you need to print the page and copy the text from there, as the ::before and ::after selectors' content cannot be selected if you drag over them, because someone might want to copy the text without formatting. This is obviously not a bug and definitely a feature :)\n","description":"An explaination od how the HTML quine on my website works","id":2,"section":"posts","tags":["quine"],"title":"A HTML Quine","uri":"https://pranavgade20.github.io/blog/posts/1_quine/"},{"content":"I\u0026rsquo;m Pranav, and this is my blog :)\n","description":"Pranav's blog","id":3,"section":"","tags":null,"title":"About","uri":"https://pranavgade20.github.io/blog/about/"}]