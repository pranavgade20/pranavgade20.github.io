[{"content":"Browsers are great. They make the Internet accessible, and parse weird-looking HTML into a beautiful document. However, organizing and looking for tabs in modern browsers is a mess. I often have quite a few tabs open from the same website, where the title is often something like Website name - page name. Now, although the website name is important, it takes up unnecessary space in the title of the page. So, the page name is usually rendered as Website name - pa.... This means that I have to cycle through a bunch of tabs until I find the page name I am looking for.\nHowever, it doesn\u0026rsquo;t have to be like this. We can trick the browser into reversing the way it renders the title. So, it will show ...ame - page name, which gives enough information to find the page I\u0026rsquo;m looking for. Before we can get to how this can be done, we need to take a quick look at how text is rendered onto your screen.\nText rendering Although a LOT goes on when a simple character is rendered onto a screen with finite resolution(see https://learnopengl.com/In-Practice/Text-Rendering), our current concern is different. In particular, we want to trick the our renderer into rendering whatever characters we have from right-to-left instead of left-to-right. So, we can safely assume that we are dealing with bitmap fonts or something else that abstracts the rendering part away. However, we do want to look at how the text is arranged.\nDifferent characters usually need to occupy different amounts of space. For example, ! occupies less space than _ does(in most non-monospace fonts). There\u0026rsquo;s also a bunch of \u0026lsquo;characters\u0026rsquo; that don\u0026rsquo;t take up any space. For example, zero-width space, a character used in typesetting doesn\u0026rsquo;t take up any space. Going a step further, are there any characters that take negative space? There\u0026rsquo;s U+A80B, an unicode character that you can repeat, and the next character appears to the left of what was rendered before it. Unfortunately, this doesn\u0026rsquo;t take us anywhere, because we can\u0026rsquo;t use this to do anything meaningful with our usual ASCII characters.\nHowever, there are certain characters that have to be written from right-to-left. For example, arabic is written from right to left. And sure enough, if we visit https://www.amazon.sa, we can see that the title is written from right-to-left, and the left is truncated if necessary. This is exactly what we want! This is basically a set of characters that have \u0026lsquo;negative\u0026rsquo; width, or written from right to left. So, have we found the solution? Not quite, unless you can read the arabic script. So, we continue our search for a way to reverse the way ASCII is rendered. According to unicode, the following bidirectional classes are rendered right to left:\n right to left: a bunch of non-ascii characters(for example, hebrew) right to left arabic: like right to left, but for arabic right to left embedding: does not override the direction of characters with strong directionality, like ASCII characters. right to left isolate: at the time of writing, not supported by WebKit browsers right to left override: strong override, causes text to be rendered right-to-left  So, the most promising candidate is the right to left override(RLO), U+202E. The following pargraph is the RLO character followed by \u0026ldquo;Hello, world\u0026rdquo;:\n‮ Hello, World   Try it yourself  You can try typing in this box to see how RLO affects text(type between \u0026gt;\u0026lt;): \n  So, we can simply reverse the string, and add U+202E to its beginning, and we should be good. Right? Unfortunately, this does not change the direction of rendering. So, even though everything is reversed, the right is truncated, unlike https://www.amazon.sa. So, the solution we have to use is the hackiest of them all: the right to left arabic bidirectional class has a curious little character: the arabic letter mark U+061C. It looks like browsers only look at the first character in a string to determine the rendering/truncation dorection, probably as n optimization. So, we can simply add U+061C to the beginning of the title, and the rendering and truncation is done exactly as we want it!\nTampermonkey Although we have figured out what we need to do, going through the source inspector, finding the title tag, and modifying it manually is simply unacceptable. So, we use tampermonkey, a browser extension that allows us to write scripts that are executed on page loading and other events. It is basically a way to write micro-extensions without worriying about most stuff you need to worry about when making a full fledged extension.\nWe use the following script to add U+061C to the title whenever it is modified.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // ==UserScript== // @name Title Fixer // @namespace https://pranavg.me/ // @version 1.1 // @description make page titles look better // @author Pranav Gade // @match *://*/* // @icon https://www.google.com/s2/favicons?domain=mozilla.org // ==/UserScript==  (function() { \u0026#39;use strict\u0026#39;; let ch = \u0026#39;\\u061C\u0026#39;; new MutationObserver(function(mutations) { if (document.title[0] != ch) document.title = ch + document.title; }).observe( document.querySelector(\u0026#39;title\u0026#39;), { subtree: true, characterData: true, childList: true } ); if (document.title[0] != ch) document.title = ch + document.title; })();   The MutationObserver adds the character to the title every time the title is changed, if our character isn\u0026rsquo;t already there. We also add the character to the title once unconditionally(when the page is first loaded). The @match line in the comment tells tampermonkey which pages we want to run this script on. *://*/* means we want to run it on all protocols, all domains, and all pages.\nAnd that\u0026rsquo;s it! Simply save the script and make sure it is enabled. You can now enjoy the superior experience of finding tabs quickly, and boost your productivity by some fraction of a percent!\n","description":"Unicode and text rendering, and a life hack to make your browsing experience better","id":0,"section":"posts","tags":["unicode","tampermonkey"],"title":"One weird hack to improve your browsing","uri":"https://pranavgade20.github.io/blog/posts/3_unicode_reverse/"},{"content":"You are sitting in \u0026lt;the class you hate\u0026gt;. The teacher is droning on about something and you are bored. You spot your friends sitting across the room. Ugh! Why did they have to sit there! Luckily, they appear just as bored as you are. You want to talk somehow, so you need to think about something creative. Hand gestures? Too much effort, plus you would be in trouble if you were caught. You think about paper balls, but that would be wasting too much paper. You finally decide to get help from your classmates, and pass post-it notes to your friend.\nThe problem Unfortunately, you are faced with another problem: because your classmates are just as bored as you are, they might think they have better ideas for your post-it notes, like origami, or paper balls to throw in the bin. Luckily, you paid attention in your networking class, so you have some tricks up your sleeve. You are confident that with a bit of work, you can guarantee you can communicate flawlessly with your friend.\nThree way handshake Deciding that this would work, you send your friend this message:\nHi, do you want to talk? Let\u0026rsquo;s keep track of our messages with numbers and send acknowledgements when you receive my messages.   Your friend replies with\nYup, lets talk! You sent me message #42.   Woohoo! your system seems like it is working. Although this may seem a bit arbitrary right now, this will start making perfect sense soon.\nSo, you send the appropriate acknowledgement. Notice that acknowledgements do not need numbers.\nI\u0026rsquo;m acknowledging message #69.   Author\u0026#39;s notes  The messages you send to your friend are highlighted\nlike this, and the messages your friend sends to you are\nhighlighted like this. Also, I will be replacing I'm acknowledging message #69 with just ACK 69 from this point. They mean the same thing, ACK is just a shorthand for acknowledge.\n  Now that you have established the connection and the rules of exchange, you are ready to send messages to your friend! Before that, however, let\u0026rsquo;s look at the messages sent so far in a nice diagram:\nsequenceDiagram participant You participant Friend You-\u0026gt;\u0026gt;Friend: 42. Hi, do you want to talk? Let’s keep\u0026lt;br\u0026gt;track of our messages with numbers and send\u0026lt;br\u0026gt;acknowledgements when you receive my messages. Friend-\u0026gt;\u0026gt;You: 69. Yup, lets talk! ACK 42 You-\u0026gt;\u0026gt;Friend: ACK 69 This was what is known as a 3-way handshake in technical-speak. The beauty of this is that your classmates can fail to pass any of these messages, and you would know(If this is confusing, take this as a given for now, and read on).\nSending messages Now that you know your friend understands the rules of the exchange, you send the following messages\nThis subject is so boring!   ACK 43 And the teacher isn\u0026rsquo;t helping!   ACK 44 What do you think?   You wait for a minute, then realize that your friend isn\u0026rsquo;t responding. Did someone decide to turn your note into a duck? Duck!\nLost messages This is where the acknowledgements and the numbers help you: since your friend hasn\u0026rsquo;t responded, you can conclude that either your message was lost, or the acknowledgement was lost. In the first case, you can just send the message again, and get ACK as usual. In the second case as well, you can send the message again. This won\u0026rsquo;t make a difference, because when you re-transmit the message, your friend will see the duplicate number, and can conclude that you didn\u0026rsquo;t receive the acknowledgement. So, they can simply re-transmit the acknowledgement. Either way, you get the acknowledgement. So, you resend the message.\nWhat do you think?   It looks like your message was transferred successfully, so you get an acknowledgement:\nACK 45 Before we proceed, let\u0026rsquo;s look at a diagram of what just happened(the dashed line means the message was lost):\nsequenceDiagram participant You participant Friend You-\u0026gt;\u0026gt;Friend: 43. This subject is so boring! Friend-\u0026gt;\u0026gt;You: ACK 43 You-\u0026gt;\u0026gt;Friend: 44. And the teacher isn't helping! Friend-\u0026gt;\u0026gt;You: ACK 44 You--XFriend: 45. What do you think? Note over You,Friend: 1 minute timeout You-\u0026gt;\u0026gt;Friend: 45. What do you think? Friend-\u0026gt;\u0026gt;You: ACK 45 Now, your friend responds:\nI\u0026rsquo;m bored out of my mind as well!   And you send an acknowledgement:\nACK 70 And you get another message:\nWhat are you doing after this class?   ACK 71 However, you receive message number 71 again:\nWhat are you doing after this class?   This looks like your ACK was lost. However, we can simply re-transmit the ACK as discussed above.\nACK 71 We can show this interaction with this diagram:\nsequenceDiagram participant You participant Friend Friend-\u0026gt;\u0026gt;You: 70. I'm bored out of my mind as well! You-\u0026gt;\u0026gt;Friend: ACK 70 Friend-\u0026gt;\u0026gt;You: 71. What are you doing after this class? You--XFriend: ACK 71 Friend-\u0026gt;\u0026gt;You: 71. What are you doing after this class? You-\u0026gt;\u0026gt;Friend: ACK 71 That\u0026rsquo;s neat, isn\u0026rsquo;t it? Using this, we can guarantee that our message will be sent, and both parties will be certain that the message is received.\nFaster messages Although this is awesome, you notice one thing: you are idle for considerable time while you wait for acknowledgements. So, we need a way to send multiple messages at once. Right now, let\u0026rsquo;s assume we can send two messages at once without waiting for acknowledgements. This number, two, is called the window size, and isn\u0026rsquo;t arbitrary. However, the discussion on how this number is decided is outside the scope of this article, so let\u0026rsquo;s assume we somehow found that two is the best number.\n  Author\u0026#39;s notes  The method of choosing the optimal window size is called flow control, and is a very interesting topic in itself. If you are interested in learning more about this, good starting points for exploration could be wikipedia.org/wiki/Sliding_window_protocol and wikipedia.org/wiki/Flow_control_(data)   Continuing the conversation you are having, you send the following messages:\nNothing interesting.   I\u0026rsquo;m going to go home and relax.   ACK 46 And do some homework   ACK 47 What about you? Any interesting plans?   Now, assume message 48 was lost, but 49 was received. So, your friend sends a Not Acknowledged message, represented by NAK.\nNAK 48 So, you resend message 48:\nAnd do some homework   Now, since your friend has message 48 as well as 49, they can send an cumulative acknowledgement for message 49, indicating that all messages until 49 have been recieved.\nCACK 49   Author\u0026#39;s notes  An interesting point to note here is that in this case, if you send a CACK for every packet, it behaves exactly like an ACK. So, you could replace all the preceding ACKs with CACKs, and it wouldn\u0026rsquo;t make a difference. This also means that we can say that ACK means the same thing as CACK in our protocol.   Let\u0026rsquo;s look at the sequence diagram for this conversation:\nsequenceDiagram participant You participant Friend You-\u0026gt;\u0026gt;Friend: 46. Nothing interesting. You-\u0026gt;\u0026gt;Friend: 47. I'm going to go home and relax. Friend-\u0026gt;\u0026gt;You: ACK 46 You--XFriend: 48. And do some homework Friend-\u0026gt;\u0026gt;You: ACK 47 You-\u0026gt;\u0026gt;Friend: 49. What about you? Any interesting plans? Friend-\u0026gt;\u0026gt;You: NAK 48 You-\u0026gt;\u0026gt;Friend: 48. And do some homework Friend-\u0026gt;\u0026gt;You: CACK 49 This is a bit more complex than the previous interactions, but you can see that we can send multiple messages at a time, and we have a mechanism for recovering lost messages. In addition to NAKs, we also re-send messages after timeouts, just like in previous cases. For a more detailed example, you can see this image, which shows an example with window size of 5.\nAnother interesting point to notice is that thanks to our numbering, your friend can order the messages on their end very easily, even though message 48 was received after message 49.\nFlow control Now, your friend continues the conversation:\nHomework doesn\u0026rsquo;t sound like fun :/   I\u0026rsquo;m going to a party tonight!   Now, imagine a scenario where your classmate is asked to forward two messages at the same time, and therefore messes up the order of messages. For example, because messages 72 and 73 were sent almost at the same time, your classmate might pass 73 before 72. So, you receive message 73 before you get message 72. Take a moment and think what your response would be based on what we have discussed so far.\nFrom your perspective, as soon as you receive 73 and not 72, you will send a NAK 72:\nNAK 72 Then, you receive message 72, so you will send a cumulative acknowledgement:\nCACK 73 Now, when your friend gets NAK 72, they will assume that the message was lost. So, they will retransmit the message:\nHomework doesn\u0026rsquo;t sound like fun :/   After this, they will receive your cumulative acknowledgement, letting them know that all messages until 73 have been received correctly.\nHowever, you will then receive message 72 again. Remember that in this case, we simply re-send the acknowledgement:\nDACK 72 When your friend receives this ACK, they will notice that this is an acknowledgement for a message that has already been acknowledged(in other words, a duplicate). Now, although they can simply ignore this, there is an interesting conclusion that can be drawn here: they are sending too many messages at once.\nThis means that the network cannot handle sending two messages at once, and they should reduce the window size. In our case, it will be reduced from 2 to 1, implying that we can send one message at a time without waiting for ACKs. Notice that now your classmate cannot mess up, because trying to forward less messages means that the accuracy increases.\nThe changing of window size to prevent conditions like we discussed is known as congestion control. In actual implementations, like the internet you are using to read this article, this reduction is done when three duplicate ACKs are received. We are using just one DACK to imply the need to reduce the window size for brevity.\nBecause this exchange was a bit more complex, we will use a different kind of diagram to show what\u0026rsquo;s happening:\ngantt dateFormat MM axisFormat %M section Friend to You 72. That doesn’t sound like fun :a1, 01, 7m 73. I'm going to a party tonight! :a2, 01, 6m 72. That doesn’t sound like fun :a3, after b1, 6m section You to Friend NAK 72 : b1, after a2, 3m CACK 73 : b2, after a1, 3m DACK 72 : b3, after a3, 3m Here, we can see that 73 is received at time=6, and you respond with NAK. Then, you get 72 at time=7, and since all the messages upto 73 are safely received, you send CACK 73. When NAK is received by your friend, message 72 is retransmitted, and when you receive it at time=15, you send a DACK.\nAt this point, the window size is reduced to allow just one message at a time. So, the conversation can be continued: (I\u0026rsquo;m representing the entire conversation as a diagram now, for brevity)\ngantt dateFormat MM axisFormat %M section Friend to You 74. Do you want to go with me? :a1, 01, 7m CACK 49 :a2, after b2, 4m 75. Great, I'll pick you up at 7. :a3, after b2, 6m section You to Friend CACK 74 : b1, after a1, 4m 49. Sure, that will be fun! : b2, after a1, 5m CACK 75 : b3, after a3, 1m This is very similar to the first conversation just after the three way handshake. You might want to draw a sequence diagram to see how it would look.\nClose sequence Noticing that the class is about to end, you want to end the logical \u0026lsquo;channel\u0026rsquo; of communication you created. So, you send a FIN message, with the last sequence number you had received. FIN just indicates that you have sent all the data that you would have liked to send, and you would like to end the connection. A typical exchange proceeds as follows:\nFIN 75   Notice that we also added the number of the last message we received to FIN. This is to tell your friend that you have received the messages until 75, and requests them to close the connection if 75 was indeed the last message sent. So, if 75 was not the last message, they can send the last message(s) before the connection is closed.\nIn our case, 75 was indeed the last message, so they respond by acknowledging. Additionally, they send a FIN message similar to ours to make sure they have received the last message:\nACK 50\nFIN 50   Since 50 was indeed the last message we wanted to send, we can respond with an acknowledgement, and close the connection:\nACK 76 When they receive the ACK, they can be assured that they have received all the data we had to send, and therefore close the connection as well. The exchange is shown in the following diagram:\nsequenceDiagram participant You participant Friend You-\u0026gt;\u0026gt;Friend: 50. FIN 76 Friend-\u0026gt;\u0026gt;You: ACK 50\u0026lt;br\u0026gt;76. FIN 50 You-\u0026gt;\u0026gt;Friend: ACK 76 Closing the connection, in your case, means stashing away your stationary. Similarly, computers free up memory and other resources when a connection is closed.\nThe final conversation To conclude, let\u0026rsquo;s look at the exchange like it was a normal conversation:\n You: This subject is so boring! And the teacher isn’t helping! What do you think?\nFriend: I’m bored out of my mind as well! What are you doing after this class?\nYou: Nothing interesting. I’m going to go home and relax. And do some homework.\nYou: What about you? Any interesting plans?\nFriend: Homework doesn’t sound like fun :/\nFriend: I’m going to a party tonight! Do you want to go with me?\nYou: Sure, that will be fun!\nFriend: Great, I\u0026rsquo;ll pick you up at 7.\n To sum it all up, that was a satisfying conversation, wasn\u0026rsquo;t it? Not only did you not die of boredom, you got invited to a party! Plus, you got to guarantee reliable, error checked, ordered delivery over an unreliable connection!\n  Author\u0026#39;s notes  That was a brief(and albeit cheesy) introduction to the Transmission Control Protocol. Because I wanted to keep it short, I had to gloss over a lot of details that make TCP even more interesting! So, if you would like to read about TCP in more detail, here is a place to start: wikipedia.org/wiki/Transmission_Control_Protocol#RFC_documents\nIf you have any suggestions or comments, you can email me at pranavgade20@gmail.com\nFinally, because I\u0026rsquo;m not hosting this on platforms like Medium I\u0026rsquo;d appreciate it if you could take a moment to fill this form/survey: https://docs.google.com/forms/d/e/1FAIpQLSfLupHnNFvB8WcZsnftwgW8dQWBoMUz0yxHANzfU8npXqsuPQ/viewform?usp=sf_link\n  ","description":"A brief introduction to the Transmission Control Protocol","id":1,"section":"posts","tags":["tcp"],"title":"An intro to TCP","uri":"https://pranavgade20.github.io/blog/posts/2_tcp/"},{"content":"I participated in TrollCAT CTF with my team, Pwnzorz, this weekend, and we placed 2nd! Considering that this was our first CTF in quite a while, we did really well, thanks to my amazing teammates Aayushman, Nils, and Uzay-G. Here are the writeups for the challenges I completed.\nReversing - Solver The challenge, archived here, says can you guess the password? and gives you a binary to reverse. Using ghidra, we get the following disassembly:\n1 2 3 4 5 6 7 8 9 10  if ((int)input[3] + (int)*input == 100) { if ((int) input[0x12] + (int) input[1] == 0xd6) { if ((int) input[4] + (int) input[2] == 0xb2) { if ((char) (input[6] ^ input[5]) == 0x4c) { if ((int) input[8] - (int) input[7] == 0x11) { if ((int) input[10] - (int) input[9] == 0x3b) { if (((int) input[0xb] + (int) input[0xc]) - (int) input[0xd] == 0x45) { if (((int) input[0xe] + (int) input[0xf]) - (int) input[0x10] == 0x1f) { if (((int) input[0x11] + (int) input[0x10]) - (int) input[0x12] == 0x58) { if ((char) (input[0x15] ^ input[0x13] ^ input[0x14]) == 0x45) {   Now, you could be smart, and know that you are supposed to use the z3 solver, or you could be me. I thought that it did not look very complex, so I got a pen and paper and started solving it manually. For example, the first line wants the sum of the fourth and first characters to be 100. So, I just assumed both of them to equal 50, which is 2 in ASCII. Similarly, I solved all of them manually in about 30 minutes. Finally, one input satisfying all the conditions is 2lY2Y4xAR?zEEE@@aajEEE. Finally, after connecting to the server using nc, we are asked the key. Giving it 2lY2Y4xAR?zEEE@@aajEEE gives us the flag!\nWeb - Nested Exploration The challenge is a link, and a hint saying something nice happens when we submit 69 times.\nLooking at the requests in devtools, we can see that a POST request is made, followed by a GET request. The response of the POST request is empty, and the response of the GET request is the webpage with n forms, where n is the number of times we have submitted the form. I noticed that the request parameter has a number, and tried changing it to 69. However, this still gave me the same response. Then, I tried to look at the cookies set by the website. Sure enough, there was a cookie with a number that increased every time I submitted the form. I just set this to 68 and submitted the form, and sure enough, the flag was in a div in the end.\n","description":"Writeup for trollcat CTF from 6th Feb, 2021","id":2,"section":"archive","tags":["writeup","ctf"],"title":"TrollcatCTF Writeup","uri":"https://pranavgade20.github.io/blog/archive/trollcatctf-21-writeup/"},{"content":"block gate This is a writeup for the \u0026lsquo;block gate\u0026rsquo; challenge from WPICTF 2020.\nThis is a forensics challenge, and we are given a minecraft world.\nAs soon as we enter the world, we see a column of water falling\u0026ndash;wrecking redstone circuits doubtlessly important to the whole affair.\nSo, after reloading the world, we can use gnembon\u0026rsquo;s carpet mod to stop the flow of water using the /tick freeze command. This is how it looks after that:\nNow, we can take our time in clearing out the water by filling that region with air using the /fillcommand:\nTo see the effects, we need to un-freeze the game using /tick freeze and boom, the water disappears:\nNow, we can start looking at the redstone circuit. A closer look shows us that two of the connections might be missing:And we have 2 vacant inputs for the output panel as well: We can try connecting them so the circuit is complete:(The repeaters are for extending the signal)\nFinally, we can look at the output. It looks like they are 7 segment displays, and a quick google search gives us the corresponding symbols:\nWe can see the 7 segment displays, and their corresponding symbols.\nNow we have practically solved the challenge. All we need to do is read the displays as they light up and we can get our flag! However, since this is repeating in a cyclic pattern, we need to figure out the beginning of the sequence. We do know that the flag is supposed to start with WPI{, so we can use that to find the start of the sequence.\nTo make writing down the sequence easier, we can use /tick rate 10 to halve the speed of the sequence(or /tick rate 5 for quarter speed and so on). Now all we need to do is write down the flag as it appears and we get our flag!\n","description":"Writeup for WpiCTF from 21st Arp, 2020","id":3,"section":"archive","tags":["writeup","ctf"],"title":"WpiCTF Writeup","uri":"https://pranavgade20.github.io/blog/archive/wpictf-20-writeup/"},{"content":"Background A quine is a program that produces its source code as its output. Now, although HTML is not a programming language, but a markup language, CSS is a turing complete language as long as you consider the accompanying HTML as well. So, this is technically a description of a HTML+CSS quine, but I think saying HTML is sufficient.\nI was introduced to the idea of a quine in the book Gödel, Escher, Bach: An Eternal Golden Braid, by Douglas Hofstadter. After I stumbled across this this talk, I thought it would be a nice way to put up information about me, because I am lazy and suck at design. Surprisingly, this is a very straightforward quine, so here are more details.\nThe quine The magic we use here is all thanks to the ::before and ::after CSS selectors. If you are new to CSS, selectors are basically a way to select specific elements so that we can change their properties like font style, color, etc. So, p::before will select the element that precedes the paragraph tag in our HTML document, and allow us to insert whatever we want in there. For example, \u0026lt;p\u0026gt;! Because we want to convert \u0026lt;p\u0026gt; Hello, World! \u0026lt;/p\u0026gt; which renders as Hello, World! to \u0026lt;p\u0026gt; Hello, World!, this is the perfect solution. So, let us start writing the CSS step by step:\n1  p::before{content:\u0026#39;\u0026lt;p\u0026gt;\u0026#39;}   This adds a \u0026lt;p\u0026gt; before all paragraph elements. Similarly, we can add the ::after selector.\n1  p::before{content:\u0026#39;\u0026lt;p\u0026gt;\u0026#39;} p::after{content:\u0026#39;\u0026lt;/p\u0026gt;\u0026#39;}   Now, all our paragraphs are surrounded with the appropriate HTML tags. However, our HTML page has a number of other tags. We can simply do the same thing for them:\n1 2 3 4 5 6 7 8 9 10 11  html::before{content:\u0026#39;\u0026lt;html\u0026gt;\u0026#39;} html::after{content:\u0026#39;\u0026lt;/html\u0026gt;\u0026#39;} head::before{content:\u0026#39;\u0026lt;head\u0026gt;\u0026#39;} head::after{content:\u0026#39;\u0026lt;/head\u0026gt;\u0026#39;} title::before{content:\u0026#39;\u0026lt;title\u0026gt;\u0026#39;} title::after{content:\u0026#39;\u0026lt;/title\u0026gt;\u0026#39;} body::before{content:\u0026#39;\u0026lt;body\u0026gt;\u0026#39;} body::after{content:\u0026#39;\u0026lt;/body\u0026gt;\u0026#39;} h1::before{content:\u0026#39;\u0026lt;h1\u0026gt;\u0026#39;} h1::after{content:\u0026#39;\u0026lt;/h1\u0026gt;\u0026#39;} h3::before{content:\u0026#39;\u0026lt;h3\u0026gt;\u0026#39;} h3::after{content:\u0026#39;\u0026lt;/h3\u0026gt;\u0026#39;} h5::before{content:\u0026#39;\u0026lt;h5\u0026gt;\u0026#39;} h5::after{content:\u0026#39;\u0026lt;/h5\u0026gt;\u0026#39;} p::before{content:\u0026#39;\u0026lt;p\u0026gt;\u0026#39;} p::after{content:\u0026#39;\u0026lt;/p\u0026gt;\u0026#39;} table::before{content:\u0026#39;\u0026lt;table\u0026gt;\u0026#39;} table::after{content:\u0026#39;\u0026lt;/table\u0026gt;\u0026#39;} tr::before{content:\u0026#39;\u0026lt;tr\u0026gt;\u0026#39;} tr::after{content:\u0026#39;\u0026lt;/tr\u0026gt;\u0026#39;} td::before{content:\u0026#39;\u0026lt;td\u0026gt;\u0026#39;;} td::after{content:\u0026#39;\u0026lt;/td\u0026gt;\u0026#39;;}   It has been straightforward so far. However, there are a couple of minor issues. First, the \u0026lt;meta\u0026gt; tag. It does not have a closing tag, as everything is inside the tag as an attribute. The solution here is pretty straightforward: include the entire tag with the attributes in the ::before selector. So, we can have this for the meta tag:\n1  meta::before{content:\u0026#39;\u0026lt;meta charset=\u0026#34;utf-8\u0026#34; name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt;\u0026#39;}   Our second problem is the \u0026lt;a\u0026gt; tags, as they have hrefs which are different in different places. thankfully, CSS has an attr() function that gives us the value of the attribute(in out case, href). So, we can use the following CSS for dealing with hyperlinks:\n1  a[href]::before{content: \u0026#34;a href=\u0026#39;\u0026#34; attr(href) \u0026#34;\u0026#39;\u0026gt;\u0026#34;} a::after{content:\u0026#39;\u0026lt;/a\u0026gt;\u0026#39;} a{display:inline; text-decoration: none}   We used [href] to make sure we select the correct \u0026lt;a\u0026gt; tags, and the display:inline is just for formatting(more on this later). text-decoration:none removes the underlines from the hyperlinks.\nThe final challenge is \u0026lt;style\u0026gt; tags. Specifically, the content in the ::after selector. Because we are using style tags to enclose this CSS, if we use style::after{content:'\u0026lt;/style\u0026gt;'}, the \u0026lt;/style\u0026gt; is interpreted as a closing tag, which is not something we want to see happening. Thankfully, just escaping the slash solves our problem, and we get the following CSS for dealing with the style tags:\n1  style::before{content:\u0026#39;\u0026lt;style\u0026gt;\u0026#39;} style::after{content:\u0026#39;\u0026lt;\\/style\u0026gt;\u0026#39;}   Although you can see \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; now, the CSS we wrote in the document is missing. This bring us to arguably the most important piece of CSS in the document:\n1  *{display:block}   This makes the CSS we have written in the document visible. Now, we have a stylesheet with the surrounding tags. This is also the reason we need the display:inline in the \u0026lt;a\u0026gt; tags, as display:block makes the text go on a new line, which doesn\u0026rsquo;t look particularly nice.\nOur page is now technically a quine, and if you copy-paste the output of the HTML into a HTML, you should get the same HTML(yes, it does get somewhat confusing). However, this looks a bit bland. So, we sprinkle some CSS magic to format the different elements:\n1 2 3 4  html{max-width:99ch; padding:1ch; margin:auto; color:#333; font-size:1.2em} style{font-size: 0.4em} *::before, *::after{color:#aebfd0; font-weight:100; font-size:0.8em; margin:0.3em} *{display:block; font-family:Monospace}   We finally have the result: a HTML that generates itself on most modern browsers. You can visit the final version at pranavgade20.github.io. Finally, a caveat: you need to print the page and copy the text from there, as the ::before and ::after selectors' content cannot be selected if you drag over them, because someone might want to copy the text without formatting. This is obviously not a bug and definitely a feature :)\n","description":"An explaination of how the HTML quine on my website works","id":4,"section":"posts","tags":["quine"],"title":"A HTML Quine","uri":"https://pranavgade20.github.io/blog/posts/1_quine/"},{"content":"I\u0026rsquo;m Pranav, and this is my blog :)\n","description":"Pranav's blog","id":5,"section":"","tags":null,"title":"About","uri":"https://pranavgade20.github.io/blog/about/"}]